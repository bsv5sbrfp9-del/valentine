<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lumea Pisicilor üêæ</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0b1020;
      color: #e8eaf6;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      top: 14px; left: 14px;
      display: grid;
      gap: 10px;
      z-index: 10;
      width: min(420px, calc(100vw - 28px));
    }
    .panel {
      background: rgba(12, 18, 40, .75);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button {
      background: #7c3aed;
      border: 0;
      color: white;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 650;
      cursor: pointer;
      transition: transform .06s ease, filter .15s ease;
      user-select: none;
    }
    button:hover { filter: brightness(1.06); }
    button:active { transform: scale(.98); }
    button.secondary { background: rgba(255,255,255,.10); border: 1px solid rgba(255,255,255,.16); }
    label {
      display: flex; gap: 8px; align-items: center;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.12);
      user-select: none;
    }
    input[type="range"] { width: 150px; }
    .hint { opacity: .9; font-size: 13px; line-height: 1.35; }
    .tiny { opacity: .75; font-size: 12px; margin-top: 8px; }
    #badge {
      position: fixed;
      bottom: 14px; right: 14px;
      background: rgba(12, 18, 40, .75);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 10px 12px;
      z-index: 10;
      font-size: 13px;
      display: flex;
      gap: 10px;
      align-items: center;
      backdrop-filter: blur(10px);
    }
    #badge b { font-weight: 800; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <div class="row">
        <button id="tameBtn">√émbl√¢nze»ôte toate ü•∫</button>
        <button id="addBtn" class="secondary">+ Mai multe pisici</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
      <div class="row" style="margin-top:10px;">
        <label>
          üê± NumƒÉr
          <input id="count" type="range" min="10" max="200" value="80">
          <span id="countVal">80</span>
        </label>
        <label>
          üîä Toarce
          <input id="sound" type="checkbox" checked>
        </label>
      </div>
      <div class="hint" style="margin-top:10px;">
        ‚Ä¢ Click / drag pe o pisicƒÉ = <b>pet</b> (m√¢ng√¢iere) <br/>
        ‚Ä¢ »öine apƒÉsat = o face mai fericitƒÉ üò∫‚ú® <br/>
        ‚Ä¢ DacƒÉ e √Æmbl√¢nzitƒÉ, vine mai des spre tine »ôi stƒÉ pe l√¢ngƒÉ cursor.
      </div>
      <div class="tiny">Tip: dacƒÉ nu se aude toarcerea, dƒÉ un click pe ecran (browserul cere interac»õiune).</div>
    </div>
  </div>

  <div id="badge">üêæ Pisici: <b id="catsN">80</b> ¬∑ üíñ Pet-uri: <b id="petsN">0</b></div>
  <canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const countSlider = document.getElementById('count');
  const countVal = document.getElementById('countVal');
  const catsN = document.getElementById('catsN');
  const petsN = document.getElementById('petsN');
  const tameBtn = document.getElementById('tameBtn');
  const addBtn = document.getElementById('addBtn');
  const resetBtn = document.getElementById('resetBtn');
  const soundToggle = document.getElementById('sound');

  let W = 0, H = 0, DPR = 1;

  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = window.innerWidth; H = window.innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ----- Cute purr audio (no files) -----
  let audio = null;
  function ensureAudio() {
    if (audio) return audio;
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!AC) return null;
    const ac = new AC();

    const noiseBuf = ac.createBuffer(1, ac.sampleRate * 2, ac.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for (let i=0; i<data.length; i++) data[i] = (Math.random()*2-1) * 0.5;

    const noise = ac.createBufferSource();
    noise.buffer = noiseBuf;
    noise.loop = true;

    const bp = ac.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 55; // purr-ish
    bp.Q.value = 1.2;

    const lp = ac.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 280;

    const gain = ac.createGain();
    gain.gain.value = 0.0;

    const lfo = ac.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 6.5;

    const lfoGain = ac.createGain();
    lfoGain.gain.value = 0.08; // modulation depth

    lfo.connect(lfoGain).connect(gain.gain);

    noise.connect(bp);
    bp.connect(lp);
    lp.connect(gain);
    gain.connect(ac.destination);

    noise.start();
    lfo.start();

    audio = { ac, gain, target: 0 };
    return audio;
  }

  function setPurrTarget(t) {
    const a = ensureAudio();
    if (!a) return;
    a.target = t;
  }

  function audioTick() {
    if (!audio) return;
    const a = audio;
    // smooth volume changes
    const now = a.ac.currentTime;
    const current = a.gain.gain.value;
    const next = current + (a.target - current) * 0.12;
    a.gain.gain.setValueAtTime(next, now);
  }

  // Resume audio on first user gesture (required by browsers)
  function resumeAudio() {
    const a = ensureAudio();
    if (a && a.ac.state !== 'running') a.ac.resume();
    window.removeEventListener('pointerdown', resumeAudio);
  }
  window.addEventListener('pointerdown', resumeAudio);

  // ----- World / Cats -----
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  const PALETTE = [
    { fur:'#f3c77a', ear:'#eaa552', stripe:'#d48a2e' },
    { fur:'#cfd8dc', ear:'#b0bec5', stripe:'#90a4ae' },
    { fur:'#f2a7b6', ear:'#ea8096', stripe:'#d95b78' },
    { fur:'#b8e3c5', ear:'#8fd1a6', stripe:'#5bb987' },
    { fur:'#e6e1ff', ear:'#b9adff', stripe:'#8a73ff' },
    { fur:'#ffd9a8', ear:'#ffb86a', stripe:'#ff9a2e' },
    { fur:'#a8d8ff', ear:'#6fbfff', stripe:'#2e9eff' },
    { fur:'#f7b7ff', ear:'#ea7bff', stripe:'#c244ff' }
  ];

  class Cat {
    constructor() {
      this.x = rand(40, W-40);
      this.y = rand(60, H-60);
      const a = rand(0, Math.PI*2);
      this.vx = Math.cos(a)*rand(18,48);
      this.vy = Math.sin(a)*rand(18,48);
      this.r = rand(14, 22);
      this.palette = PALETTE[(Math.random()*PALETTE.length)|0];
      this.happy = rand(0.1, 0.4);      // 0..1
      this.tame = Math.random() < 0.25; // some start tame
      this.petHeat = 0;                 // boosts purr & hearts
      this.blink = rand(0, 1);
      this.meowCooldown = rand(0, 3);
      this.wiggle = rand(0, 10);
    }

    update(dt, mouse) {
      // wander + slight wiggle
      this.wiggle += dt * rand(0.6, 1.3);
      const wander = 0.7 + 0.6*Math.sin(this.wiggle);

      // If tamed, attracted to mouse
      let ax = 0, ay = 0;
      if (this.tame && mouse.active) {
        const dx = mouse.x - this.x;
        const dy = mouse.y - this.y;
        const d = Math.hypot(dx,dy) || 1;
        const strength = clamp(220 / (d+40), 0, 3.2); // closer => stronger
        ax += (dx/d) * strength * 120;
        ay += (dy/d) * strength * 120;
      }

      // Random drift
      ax += rand(-18, 18) * wander;
      ay += rand(-18, 18) * wander;

      // Integrate
      this.vx += ax * dt;
      this.vy += ay * dt;

      // speed limit
      const sp = Math.hypot(this.vx,this.vy) || 1;
      const maxSp = this.tame ? 95 : 120;
      if (sp > maxSp) {
        this.vx = (this.vx/sp) * maxSp;
        this.vy = (this.vy/sp) * maxSp;
      }

      // move
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      // bounce off walls
      const pad = this.r + 10;
      if (this.x < pad) { this.x = pad; this.vx *= -0.85; }
      if (this.x > W - pad) { this.x = W - pad; this.vx *= -0.85; }
      if (this.y < pad+30) { this.y = pad+30; this.vy *= -0.85; }
      if (this.y > H - pad) { this.y = H - pad; this.vy *= -0.85; }

      // happiness decay & pet heat decay
      this.happy = clamp(this.happy - dt * 0.018, 0, 1);
      this.petHeat = Math.max(0, this.petHeat - dt * 0.9);

      // blinking
      this.blink += dt * rand(0.2, 0.6);

      // slight friction
      this.vx *= (1 - dt * 0.15);
      this.vy *= (1 - dt * 0.15);
    }

    contains(px,py) {
      return Math.hypot(px-this.x, py-this.y) <= this.r*1.35;
    }

    pet() {
      this.happy = clamp(this.happy + 0.08, 0, 1);
      this.petHeat = clamp(this.petHeat + 0.55, 0, 1.3);
      // a tiny nudge
      this.vx += rand(-35, 35);
      this.vy += rand(-35, 35);
    }

    makeTame() {
      this.tame = true;
      this.happy = clamp(this.happy + 0.18, 0, 1);
      this.petHeat = clamp(this.petHeat + 0.35, 0, 1.3);
    }

    draw(ctx) {
      // shadow
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(this.x, this.y + this.r*1.15, this.r*1.1, this.r*0.55, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // body
      const { fur, ear, stripe } = this.palette;
      ctx.save();
      ctx.translate(this.x, this.y);

      // tail
      const tailW = this.r*0.55;
      const tailL = this.r*1.8;
      const wag = Math.sin(this.wiggle*1.3) * (this.tame ? 0.65 : 0.35);
      ctx.lineCap = 'round';
      ctx.strokeStyle = stripe;
      ctx.lineWidth = tailW;
      ctx.beginPath();
      ctx.moveTo(-this.r*0.95, this.r*0.35);
      ctx.quadraticCurveTo(-this.r*1.6, this.r*0.2 - wag*this.r, -this.r*1.25, -this.r*0.7 - wag*this.r);
      ctx.stroke();

      // body blob
      ctx.fillStyle = fur;
      ctx.beginPath();
      ctx.ellipse(0, this.r*0.35, this.r*1.15, this.r*0.95, 0, 0, Math.PI*2);
      ctx.fill();

      // stripes
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = stripe;
      for (let i=0;i<3;i++){
        ctx.beginPath();
        ctx.ellipse(this.r*0.2 + i*2, this.r*0.35 - i*3, this.r*0.55, this.r*0.18, -0.35, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // head
      ctx.fillStyle = fur;
      ctx.beginPath();
      ctx.arc(0, -this.r*0.45, this.r*0.85, 0, Math.PI*2);
      ctx.fill();

      // ears
      ctx.fillStyle = fur;
      ctx.beginPath();
      ctx.moveTo(-this.r*0.55, -this.r*1.05);
      ctx.lineTo(-this.r*0.15, -this.r*0.85);
      ctx.lineTo(-this.r*0.55, -this.r*0.55);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(this.r*0.55, -this.r*1.05);
      ctx.lineTo(this.r*0.15, -this.r*0.85);
      ctx.lineTo(this.r*0.55, -this.r*0.55);
      ctx.closePath();
      ctx.fill();

      // inner ear
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = ear;
      ctx.beginPath();
      ctx.moveTo(-this.r*0.50, -this.r*0.97);
      ctx.lineTo(-this.r*0.25, -this.r*0.85);
      ctx.lineTo(-this.r*0.50, -this.r*0.62);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(this.r*0.50, -this.r*0.97);
      ctx.lineTo(this.r*0.25, -this.r*0.85);
      ctx.lineTo(this.r*0.50, -this.r*0.62);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // face features
      const blink = (Math.sin(this.blink*2.2) > 0.985) ? 0.05 : 1; // occasional blink
      const eyeY = -this.r*0.55;
      const eyeX = this.r*0.25;
      const eyeW = this.r*0.16;
      const eyeH = this.r*0.22 * blink;

      // eyes
      ctx.fillStyle = '#0b1020';
      ctx.beginPath();
      ctx.ellipse(-eyeX, eyeY, eyeW, Math.max(2, eyeH), 0, 0, Math.PI*2);
      ctx.ellipse( eyeX, eyeY, eyeW, Math.max(2, eyeH), 0, 0, Math.PI*2);
      ctx.fill();

      // sparkle (when happy)
      if (this.happy > 0.55) {
        ctx.globalAlpha = clamp((this.happy - 0.55) / 0.45, 0, 1) * 0.9;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(-eyeX-2, eyeY-2, 1.4, 0, Math.PI*2);
        ctx.arc( eyeX-2, eyeY-2, 1.4, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // nose
      ctx.fillStyle = '#ffb3c1';
      ctx.beginPath();
      ctx.moveTo(0, -this.r*0.40);
      ctx.lineTo(-this.r*0.06, -this.r*0.32);
      ctx.lineTo(this.r*0.06, -this.r*0.32);
      ctx.closePath();
      ctx.fill();

      // mouth
      ctx.strokeStyle = 'rgba(0,0,0,.55)';
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(0, -this.r*0.30);
      ctx.quadraticCurveTo(-this.r*0.08, -this.r*0.20, -this.r*0.18, -this.r*0.20);
      ctx.moveTo(0, -this.r*0.30);
      ctx.quadraticCurveTo(this.r*0.08, -this.r*0.20, this.r*0.18, -this.r*0.20);
      ctx.stroke();

      // whiskers
      ctx.strokeStyle = 'rgba(255,255,255,.65)';
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      for (let s of [-1,1]) {
        ctx.moveTo(s*this.r*0.25, -this.r*0.33);
        ctx.lineTo(s*this.r*0.62, -this.r*0.42);
        ctx.moveTo(s*this.r*0.25, -this.r*0.28);
        ctx.lineTo(s*this.r*0.65, -this.r*0.28);
        ctx.moveTo(s*this.r*0.25, -this.r*0.23);
        ctx.lineTo(s*this.r*0.62, -this.r*0.14);
      }
      ctx.stroke();

      // Heart when being petted
      if (this.petHeat > 0.15) {
        const a = clamp((this.petHeat - 0.15)/1.15, 0, 1);
        ctx.globalAlpha = 0.9 * a;
        ctx.fillStyle = '#ff4d6d';
        const hx = this.r*0.95;
        const hy = -this.r*1.25 - a*10;
        const hs = this.r*0.18 + a*2.2;
        drawHeart(ctx, hx, hy, hs);
        ctx.globalAlpha = 1;
      }

      // Tame badge (tiny halo)
      if (this.tame) {
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = '#a78bfa';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -this.r*0.55, this.r*1.05, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    }
  }

  function drawHeart(ctx, x, y, s) {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.bezierCurveTo(x - 2*s, y - 2*s, x - 4*s, y + s, x, y + 3*s);
    ctx.bezierCurveTo(x + 4*s, y + s, x + 2*s, y - 2*s, x, y);
    ctx.fill();
  }

  // background stars
  const stars = Array.from({length: 120}, () => ({
    x: Math.random(), y: Math.random(),
    r: rand(0.4, 1.4),
    tw: rand(0, 10)
  }));

  function drawBg(t) {
    // gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#0b1020');
    g.addColorStop(1, '#070a14');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // stars
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#ffffff';
    for (const s of stars) {
      const tw = 0.5 + 0.5*Math.sin(t*0.001 + s.tw);
      ctx.globalAlpha = 0.15 + tw*0.45;
      ctx.beginPath();
      ctx.arc(s.x*W, s.y*H, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // ground
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.fillStyle = 'rgba(255,255,255,.04)';
    ctx.fillRect(0, H-90, W, 90);
    ctx.globalAlpha = 0.7;
    ctx.strokeStyle = 'rgba(255,255,255,.07)';
    ctx.lineWidth = 2;
    for (let i=0;i<6;i++){
      const y = H-90 + i*14;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(W, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  let cats = [];
  let pets = 0;

  function setCount(n) {
    n = Math.max(1, Math.floor(n));
    if (n > cats.length) {
      for (let i=cats.length; i<n; i++) cats.push(new Cat());
    } else if (n < cats.length) {
      cats.length = n;
    }
    catsN.textContent = String(cats.length);
  }

  // init
  setCount(Number(countSlider.value));
  countVal.textContent = countSlider.value;

  countSlider.addEventListener('input', () => {
    countVal.textContent = countSlider.value;
    setCount(Number(countSlider.value));
  });

  addBtn.addEventListener('click', () => {
    const add = 20;
    countSlider.value = String(Math.min(200, Number(countSlider.value) + add));
    countVal.textContent = countSlider.value;
    setCount(Number(countSlider.value));
  });

  resetBtn.addEventListener('click', () => {
    pets = 0; petsN.textContent = "0";
    cats = [];
    setCount(Number(countSlider.value));
  });

  tameBtn.addEventListener('click', () => {
    for (const c of cats) c.makeTame();
  });

  // mouse interaction
  const mouse = { x: W/2, y: H/2, down: false, active: false };
  let petting = false;
  let petVolume = 0;

  function pointerPos(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  function doPetAt(x,y) {
    // find nearest cat under cursor
    let hit = null;
    for (let i=cats.length-1; i>=0; i--) {
      if (cats[i].contains(x,y)) { hit = cats[i]; break; }
    }
    if (hit) {
      hit.pet();
      pets++;
      petsN.textContent = String(pets);

      // If you pet enough, it becomes tame naturally
      if (!hit.tame && hit.happy > 0.72 && Math.random() < 0.35) hit.makeTame();

      // purr intensity
      petVolume = clamp(petVolume + 0.18, 0, 1);
      return true;
    }
    return false;
  }

  canvas.addEventListener('pointerdown', (e) => {
    const p = pointerPos(e);
    mouse.x = p.x; mouse.y = p.y;
    mouse.down = true; mouse.active = true;
    petting = doPetAt(p.x, p.y);
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e) => {
    const p = pointerPos(e);
    mouse.x = p.x; mouse.y = p.y;
    mouse.active = true;

    if (mouse.down) {
      // pet while dragging
      const ok = doPetAt(p.x, p.y);
      petting = petting || ok;
    }
  });

  canvas.addEventListener('pointerup', () => {
    mouse.down = false;
    petting = false;
  });

  canvas.addEventListener('pointerleave', () => {
    mouse.active = false;
  });

  // loop
  let last = performance.now();
  function frame(t) {
    const dt = Math.min(0.033, (t - last) / 1000);
    last = t;

    drawBg(t);

    // update + draw cats
    for (const c of cats) c.update(dt, mouse);

    // draw sorted by y for cute depth
    cats.slice().sort((a,b)=>a.y-b.y).forEach(c => c.draw(ctx));

    // purr: stronger if actively petting and nearby cats are happy
    const happyPurr = cats.reduce((acc,c)=>acc + c.petHeat, 0) / Math.max(1, cats.length);
    const want = (soundToggle.checked && (petting || happyPurr > 0.12)) ? clamp(0.06 + happyPurr*0.35 + petVolume*0.25, 0, 0.55) : 0;
    setPurrTarget(want);
    audioTick();
    petVolume = Math.max(0, petVolume - dt * 0.55);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
